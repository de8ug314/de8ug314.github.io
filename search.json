[{"title":"xhlink-arm初见与栈重复利用","date":"2022-03-19T23:06:37.000Z","url":"/2022/03aefc80db.html","tags":[["pwn","/tags/pwn/"],["wp","/tags/wp/"]],"categories":[["pwn","/categories/pwn/"]],"content":"之前一次蓝队面试的时候被面试官嘲笑经验不足了，于是痛下决心挖了几天漏洞，结果从edu到一般的src项目，一个洞也没挖到:cry:。于是收拾收拾就回到了学pwn的不归之路。 题目是某击剑比赛的线下题，据提供题目给我的师傅说这是个签到题。不过以我的水平也是在师傅提供基本方向和各种hint的情况下才做出来，学到了很多，故此记。 题目附件如下： 百度一番后发现是路由器固件linux下命令 binwalk -Me xhlink.hsqs便可将其中的文件分离出来 一开始年轻不懂事，马上兴致勃勃的启动了start.sh这个看起来是一切的开始的文件。结果直接把虚拟机都搞得千疮百孔，完全是被初见杀了。 原来直接分析cli就可以了，checksec后发现是个arm的。这个环境的基本配置流程就是安装qemu–&gt;安装相关arm(网上看到的教程是安装的带gdb的库)–&gt;安装gdb-multiarch以调试。根据网上有的教程配好环境后发现会有个 /lib/ld-linux.so.3 not find 的情况。最后发现apt安装libc6-armhf-cross即可解决。 启动程序 程序是这么个样子，因为事先听师傅说是命令注入了。于是每个能输入的地方后面都姑且添加个&amp;ls和&amp;&amp;ls试了试。经过反复碰壁，最后发现在logs_download这个功能里会发生些有异常的事。 首先在主菜单胡乱输入些命令报错，让它产生日志（当然，这个功能的具体是反复摸索得到的，因为我刚开始就瞎打了些命令报了不少错，所以第一次下载日志就成功了，之后重新打开程序直接下载日志的话需要再次产生错误日志后才能下载）。 进入功能，发现要输入文件名，感觉是一个比较唐突的要求，于是进入逆向分析 这里我用的cutter，是一个开源的逆向工具，似乎是有集众家之所长吧，不过我用这个几乎就是因为它能同时分窗口现实汇编和伪c。界面如下 这里就直接搜索Enter the log filename这个字符串，看看什么地方引用了它 发现有这么个结果，点进去康康，是个存储静态字符串的段，右键查看交叉引用 找到了相关汇编代码 发现这个居然会过滤../和flag，感觉似乎是走在了正常解题的大道上了 然后在这里看到了非常像日志的一个文件，本机上也发现了这个/var/log/cli_logs,于是回到程序输入，发现进入了下一步 它又提出了新的要求，继续反汇编分析 惊喜的发现下面有个格式化字符串，百度tftp发现是个可用于网络传输的工具(我的ubuntu没有，apt安装后可正常执行) 那么可以猜测，这个格式化好的字符串之后肯定会直接当作命令执行，而第三个%s肯定就是我们可以控制的ip地址，如果输入类似127.0.0.1&amp;ls的话，不就可以了吗 发现检测出了我的非法操作，感觉又离真相近了一步。 用交叉引用检索Illegal input发现存在这样的一个检测函数 作为一个(前（菜鸟web手))，下意识就开始百度各种bypass的方法，发现都不行，过滤的太死了。于是又向师傅要了新的hint，他让我关注栈数据。我好像有了点头绪。然后就不得不进行动态调试了 qemu-arm下的调试是需要远程的，具体操作如下: 经过一番摸索和练习。（网上没有找到详细正规的调试方法） 发现基本调试方法如下，在gdb中输入c，使源程序运行起来，在有输入的地方，比如刚才输入ip的地方输入127.0.0.1&amp;ls并且按下ctrl-c这时候程序并不会打断而是会以^C的形式跟在后面，再按下回车，程序便会暂停，回到gdb可以进行动态调试 前戏这么长，终于到了这个trick的地方了。在我探索的时候发现，刚刚断下的时候栈中并没有127.0.0.1&amp;ls相关的字符串，当然地，因为程序用read处理输入的字符串，要进行处理并放入栈还要进行很多步。然而，当地二次进行同样操作的时候却有了惊奇地发现（由于环境问题，这里ip最好是改成127.0.0.1&amp;&amp;ls，使这个下载功能直接报错退出，至于为什么就是一个很玄学的问题了，否则会一直卡在Starting download… 让人动弹不得，我在写这文章的时候又踩到这个坑了:laughing:，以下步骤都改成在127.0.0.1&amp;&amp;ls的情况下进行） 这里一开是就出现字符串了，这是为什么呢?我想起了放在大脑深处的函数栈知识，我们把这个输入并进行检测的函数称作check_func，那么第一次执行的栈如下图(经过抽象简化): 而由于这个程序本质上是个循环，所以当我们第二次再执行到check_func时，栈又会回到和上次相同的地方。而上次栈的内容是没有清除的，所以这个字符串也会留在这里。而再观察这个字符串，发现是有&amp;的，这是因为check_func用read一个一个读入字符，并放入存储，发现异常字符就立刻推出，而没有排除或者修改这个异常字符，所以这个&amp;也被保留了下来。 那么比如我们第一次输入123456ls&amp;&amp;(加个&amp;&amp;是为了防止卡在Starting download…),第二次输入de8ug&amp;,就能被拼接成de8ug&amp;ls，这样再被放到tftp的命令中去执行，就能成功执行到后面的ls 这样就能命令执行了。 虽然只是个签到题，不过却非常有意思。比如检测那里，如果不是我在栈中看到了read读取后的数据，可能就不会去注意检测的程序有不完善的地方，而正是这个小问题，配合了栈的这个机制就造成了这么大的漏洞"},{"title":"makise-kurise","date":"2010-08-21T10:38:45.000Z","url":"/2010/08b8ef5cec.html","categories":[["undefined",""]],"content":"this is my first makise kurisuそれは私の最初の牧瀬紅莉栖。"}]