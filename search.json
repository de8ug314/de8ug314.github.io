[{"title":"pwntools调试exp效果的技巧及一些坑","date":"2022-04-13T06:36:37.000Z","url":"/2022/047e1db425.html","tags":[["pwn","/tags/pwn/"]],"categories":[["pwn","/categories/pwn/"]],"content":"虽然网上有许多介绍调试相关技巧的文章了，但是有一些自己踩到的坑还很少被指出来，所以在这里作一点总结。 1.gdb.attach的方式: 用这个方式来断点的缺点是不好断到main函数，因为使用process()申请进程后可能马上就会进入到main函数内。 正常情况下使用方式如下： 在发送数据之前使用gdb.attach来执行断点命令(这里的debug和sdl分别是我的项目，一个exp的模板对gdb.attach和sendline的封装)，然后pause。使用场景一般是我们想查看发送的数据对内存的影响，如果不加pause的话一般会断在read函数的某处。 运行exp会弹出上图右方的gdb终端，然后在左边的终端按任意键，看到自己要发送的内存发送过后，接着在右边终端输入c（继续）的命令，便能够正常断点 接下来就可以像正常的gdb调试一样查看stack，heap，单步调试之类的了 ​ 然而以上的正常使用是我在身处错误的调教姿势很长时间后才猛然发现的，事实上有一下两个大坑 ​ 问题（1）运行exp后不弹出新的窗口，如下图 目前所知的比较好解决方法有两个： 一个是将gdb的插件pwndbg替换为peda，peda就能正常弹出窗口。其实可以给root和普通用户分别安装pwndbg和peda，因为插件是安装在用户主目录的，所以不同用户启动gdb时能有启动不同插件的效果。 另外一个就是安装tmux终端，这是一个终端的分屏软件，这个解决方法网上大概都有教程了。在tmux终端下执行exp后会自动分屏出现一个gdb的界面 。 问题（2）一直处于Wating for debugger状态导致无法正确断点 这种状态有些情况下能断到read的地方，而不是自己想断的位置，并且不能单步调式。 我现在在解决这个问题后才发现自己在过去几个月的打pwn之路中一直在承受着这不完全调试状态下的痛苦，顿时就重燃希望了有木有（虽然该不会的题还是不会） 解决方法可以参考这位师傅的文章，修改pwntools相关函数下的内容，师傅分析的很详细，不过只是复制粘贴完事的话还是很快的 2.使用gdb.debug断点 用这种断点方式能够轻易做到方法1做不到的时是（断main） 使用方法就是用gdb.debug替换掉以前的process来创建进程 ```p=gdb.debug(‘./pwn’,’b main’)`` 希望这篇文章能够帮助到因为一些环境错误而不能正常调试并饱受折磨的师傅们:pray:"},{"title":"xhlink-arm初见与栈重复利用","date":"2022-03-19T23:06:37.000Z","url":"/2022/03aefc80db.html","tags":[["pwn","/tags/pwn/"],["wp","/tags/wp/"]],"categories":[["pwn","/categories/pwn/"]],"content":"之前一次蓝队面试的时候被面试官嘲笑经验不足了，于是痛下决心挖了几天漏洞，结果从edu到一般的src项目，一个洞也没挖到:cry:。于是收拾收拾就回到了学pwn的不归之路。 题目是某击剑比赛的线下题，据提供题目给我的师傅说这是个签到题。不过以我的水平也是在师傅提供基本方向和各种hint的情况下才做出来，学到了很多，故此记。 题目附件如下： 百度一番后发现是路由器固件linux下命令 binwalk -Me xhlink.hsqs便可将其中的文件分离出来 一开始年轻不懂事，马上兴致勃勃的启动了start.sh这个看起来是一切的开始的文件。结果直接把虚拟机都搞得千疮百孔，完全是被初见杀了。 原来直接分析cli就可以了，checksec后发现是个arm的。这个环境的基本配置流程就是安装qemu–&gt;安装相关arm(网上看到的教程是安装的带gdb的库)–&gt;安装gdb-multiarch以调试。根据网上有的教程配好环境后发现会有个 /lib/ld-linux.so.3 not find 的情况。最后发现apt安装libc6-armhf-cross即可解决。 启动程序 程序是这么个样子，因为事先听师傅说是命令注入了。于是每个能输入的地方后面都姑且添加个&amp;ls和&amp;&amp;ls试了试。经过反复碰壁，最后发现在logs_download这个功能里会发生些有异常的事。 首先在主菜单胡乱输入些命令报错，让它产生日志（当然，这个功能的具体是反复摸索得到的，因为我刚开始就瞎打了些命令报了不少错，所以第一次下载日志就成功了，之后重新打开程序直接下载日志的话需要再次产生错误日志后才能下载）。 进入功能，发现要输入文件名，感觉是一个比较唐突的要求，于是进入逆向分析 这里我用的cutter，是一个开源的逆向工具，似乎是有集众家之所长吧，不过我用这个几乎就是因为它能同时分窗口现实汇编和伪c。界面如下 这里就直接搜索Enter the log filename这个字符串，看看什么地方引用了它 发现有这么个结果，点进去康康，是个存储静态字符串的段，右键查看交叉引用 找到了相关汇编代码 发现这个居然会过滤../和flag，感觉似乎是走在了正常解题的大道上了 然后在这里看到了非常像日志的一个文件，本机上也发现了这个/var/log/cli_logs,于是回到程序输入，发现进入了下一步 它又提出了新的要求，继续反汇编分析 惊喜的发现下面有个格式化字符串，百度tftp发现是个可用于网络传输的工具(我的ubuntu没有，apt安装后可正常执行) 那么可以猜测，这个格式化好的字符串之后肯定会直接当作命令执行，而第三个%s肯定就是我们可以控制的ip地址，如果输入类似127.0.0.1&amp;ls的话，不就可以了吗 发现检测出了我的非法操作，感觉又离真相近了一步。 用交叉引用检索Illegal input发现存在这样的一个检测函数 作为一个(前（菜鸟web手))，下意识就开始百度各种bypass的方法，发现都不行，过滤的太死了。于是又向师傅要了新的hint，他让我关注栈数据。我好像有了点头绪。然后就不得不进行动态调试了 qemu-arm下的调试是需要远程的，具体操作如下: 经过一番摸索和练习。（网上没有找到详细正规的调试方法） 发现基本调试方法如下，在gdb中输入c，使源程序运行起来，在有输入的地方，比如刚才输入ip的地方输入127.0.0.1&amp;ls并且按下ctrl-c这时候程序并不会打断而是会以^C的形式跟在后面，再按下回车，程序便会暂停，回到gdb可以进行动态调试 前戏这么长，终于到了这个trick的地方了。在我探索的时候发现，刚刚断下的时候栈中并没有127.0.0.1&amp;ls相关的字符串，当然地，因为程序用read处理输入的字符串，要进行处理并放入栈还要进行很多步。然而，当地二次进行同样操作的时候却有了惊奇地发现（由于环境问题，这里ip最好是改成127.0.0.1&amp;&amp;ls，使这个下载功能直接报错退出，至于为什么就是一个很玄学的问题了，否则会一直卡在Starting download… 让人动弹不得，我在写这文章的时候又踩到这个坑了:laughing:，以下步骤都改成在127.0.0.1&amp;&amp;ls的情况下进行） 这里一开是就出现字符串了，这是为什么呢?我想起了放在大脑深处的函数栈知识，我们把这个输入并进行检测的函数称作check_func，那么第一次执行的栈如下图(经过抽象简化): 而由于这个程序本质上是个循环，所以当我们第二次再执行到check_func时，栈又会回到和上次相同的地方。而上次栈的内容是没有清除的，所以这个字符串也会留在这里。而再观察这个字符串，发现是有&amp;的，这是因为check_func用read一个一个读入字符，并放入存储，发现异常字符就立刻推出，而没有排除或者修改这个异常字符，所以这个&amp;也被保留了下来。 那么比如我们第一次输入123456ls&amp;&amp;(加个&amp;&amp;是为了防止卡在Starting download…),第二次输入de8ug&amp;,就能被拼接成de8ug&amp;ls，这样再被放到tftp的命令中去执行，就能成功执行到后面的ls 这样就能命令执行了。 虽然只是个签到题，不过却非常有意思。比如检测那里，如果不是我在栈中看到了read读取后的数据，可能就不会去注意检测的程序有不完善的地方，而正是这个小问题，配合了栈的这个机制就造成了这么大的漏洞"},{"title":"makise-kurise","date":"2010-08-21T10:38:45.000Z","url":"/2010/08b8ef5cec.html","categories":[["undefined",""]],"content":"this is my first makise kurisuそれは私の最初の牧瀬紅莉栖。"}]